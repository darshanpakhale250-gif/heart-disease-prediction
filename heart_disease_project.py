# -*- coding: utf-8 -*-
"""Heart_Disease_Project.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1M2SYE0tgWQX_XdCxKj_vmlOKRqbzrKW3
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

df = pd.read_csv('/content/dataset (1).csv')
df

'''1. Data Analysis:
a. Import the dataset
b. Get information about the dataset (mean, max, min, quartiles etc.)
c. Find the correlation between all fields'''

display(df.mean())
display(df.max())
display(df.min())
display(df.quantile())
display(df.corr())

'''2. Data Visualization:
a. Visualize the number of patients having a heart disease and not having
a heart disease
b. Visualize the age and whether a patient has disease or not
c. Visualize correlation between all features using a heat map'''

plt.figure(figsize=(10,5))
sns.boxplot(x='target', y='age', data=df)
plt.xticks([0, 1], ['No Heart Disease', 'Heart Disease'])
plt.xlabel('Heart Disease')
plt.ylabel('Age')
plt.title('Age Distribution vs. Heart Disease')
plt.show()     # for b more accurate

plt.figure(figsize = (12,12))
sns.heatmap(df.corr(), annot=True, cmap='plasma' , fmt = ".2f")
plt.title('Correlation Matrix of Heart Disease Dataset')
plt.show()

age_disease = df.groupby('target')['age'].mean().reset_index()

plt.figure(figsize=(8, 5))
sns.barplot(x='target', y='age', data=age_disease)
plt.xticks([0, 1], ['No Heart Disease', 'Heart Disease'])
plt.xlabel('Heart Disease')
plt.ylabel('Average Age')
plt.title('Average Age vs. Heart Disease')
plt.show()

fig = plt.figure(figsize=(10,5))
sns.countplot(x='target',data=df)
plt.xticks([0, 1], ['No', 'Yes'])
plt.xlabel('Heart Disease')
plt.ylabel('Count')
plt.title('Distribution of Heart Disease')
plt.tight_layout()
plt.show()

#Logistic Regression
from sklearn.model_selection import train_test_split
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import cross_val_score
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

'''3. Logistic Regression:
a. Build a simple logistic regression model:
i. Divide the dataset in 70:30 ratio
ii. Build the model on train set and predict the values on test set
iii. Build the confusion matrix and get the accuracy score'''
X = df.drop('target', axis = 1)
y = df['target']

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
model = LogisticRegression()
model.fit(X_train , y_train)

y_pred = model.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy}")

conf_matrix_logistic1 = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(conf_matrix_logistic1)

report_logistic1 = classification_report(y_test, y_pred)
print("Classification Report:")
print(report_logistic1)



'''Decision Tree:
a. Build a decision tree model:
i. Divide the dataset in 70:30 ratio
ii. Build the model on train set and predict the values on test set
iii. Build the confusion matrix and calculate the accuracy
iv. Visualize the decision tree using the Graphviz package'''
from sklearn.tree import DecisionTreeClassifier
from sklearn.tree import export_graphviz
import graphviz

X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3, random_state=42)
model = DecisionTreeClassifier()
model.fit(X_train, y_train)

y_pred = model.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy}")

conf_matrix_decision = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(conf_matrix_decision)

report_decision = classification_report(y_test , y_pred)
print("Classification Report:")
print(report_decision)



for depth in range(1, 11):   # from 1 to 10
    # Create a decision tree with given depth
    model = DecisionTreeClassifier(max_depth=depth, random_state=42)


       # Train the model
    model.fit(X_train, y_train)

    # Predict on test data
    y_pred = model.predict(X_test)

    # Calculate accuracy
    acc = accuracy_score(y_test, y_pred)

    # Print the depth and accuracy
    print(f"Depth: {depth} → Accuracy: {acc:.3f}")

from sklearn.tree import export_graphviz
import graphviz

dot_data = export_graphviz(model,
                           out_file=None,
                           feature_names=X.columns,
                           class_names=['No Disease', 'Disease'],
                           filled=True, rounded=True,
                           special_characters=True)

# Visualize the tree
graph = graphviz.Source(dot_data)
graph.render("decision_tree")   # saves as PDF
graph

'''Random Forest:
a. Build a Random Forest model:
i. Divide the dataset in 70:30 ratio
ii. Build the model on train set and predict the values on test set
iii. Build the confusion matrix and calculate the accuracy
iv. Visualize the model using the Grap'''
from sklearn.ensemble import RandomForestClassifier

X_train, X_test, y_train, y_test = train_test_split(X , y , test_size = 0.3 , random_state = 42)
model = RandomForestClassifier()
model.fit(X_train , y_train)

y_pred = model.predict(X_test)

accuracy = accuracy_score(y_test, y_pred)
print(f"Accuracy: {accuracy}")

conf_matrix_random = confusion_matrix(y_test, y_pred)
print("Confusion Matrix:")
print(conf_matrix_random)

report_random = classification_report(y_test, y_pred)
print("Classification Report:")
print(report_random)

# Single decision tree
dt = DecisionTreeClassifier(max_depth=5, random_state=42)
dt.fit(X_train, y_train)
print("Decision Tree Accuracy:", dt.score(X_test, y_test))

# Random forest with 100 trees
rf = RandomForestClassifier(n_estimators=150, max_depth=5, random_state=42)
rf.fit(X_train, y_train)
print("Random Forest Accuracy:", rf.score(X_test, y_test))

from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import export_graphviz
import graphviz


# Train Random Forest
rf = RandomForestClassifier(n_estimators=5, max_depth=3, random_state=42)
rf.fit(X, y)

# Pick one decision tree from the forest (e.g., the first one)
estimator = rf.estimators_[0]

# Export that tree to DOT format
dot_data = export_graphviz(estimator,
                           out_file=None,
                           feature_names= X.columns,
                           class_names= ['No Disease' , 'Disease'],
                           filled=True, rounded=True,
                           special_characters=True)

# Visualize using Graphviz
graph = graphviz.Source(dot_data)
graph.render("random_forest_tree")   # saves as random_forest_tree.pdf
graph

from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import export_graphviz
import graphviz

# Train Random Forest
rf = RandomForestClassifier(n_estimators=5, max_depth=4, random_state=42)
rf.fit(X, y)  # Replace X, y with your dataset

# Visualize first 3 trees
for i, tree in enumerate(rf.estimators_[:3]):
    dot_data = export_graphviz(tree,
                               out_file=None,
                               feature_names=X.columns,
                               class_names=['No Disease', 'Disease'],
                               filled=True, rounded=True,
                               special_characters=True)
    graph = graphviz.Source(dot_data)
    graph.render(f"random_forest_tree_{i}")  # Saves as PDF
    display(graph)  # Works only in Jupyter Notebook

from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import export_graphviz
import graphviz
from IPython.display import display

# Train Random Forest
rf = RandomForestClassifier(n_estimators=5, max_depth=4, random_state=42)
rf.fit(X, y)

# Visualize and save first 3 trees
for i, tree in enumerate(rf.estimators_[:3]):
    dot_data = export_graphviz(tree,
                               out_file=None,
                               feature_names=X.columns,
                               class_names=['No Disease', 'Disease'],
                               filled=True, rounded=True,
                               special_characters=True)
    graph = graphviz.Source(dot_data)

    # Save as PDF (to /content/ directory)
    output_path = f"/content/random_forest_tree_{i}.pdf"
    graph.render(output_path, view=False, cleanup=True, format='pdf')

    print(f"✅ Saved: {output_path}")
    display(graph)  # Show inline in Colab

from sklearn.ensemble import RandomForestClassifier
from sklearn.tree import export_graphviz
import graphviz, os
from google.colab import files

# 1. Train model
rf = RandomForestClassifier(n_estimators=5, max_depth=4, random_state=42)
rf.fit(X, y)

# 2. Create a folder to store the outputs
os.makedirs("/content/trees", exist_ok=True)

# 3. Loop through first 3 trees and save
for i, tree in enumerate(rf.estimators_[:3]):
    dot_path = f"/content/trees/tree_{i}.dot"
    pdf_path = f"/content/trees/tree_{i}.pdf"

    # Export to .dot file
    export_graphviz(tree,
                    out_file=dot_path,
                    feature_names=X.columns,
                    class_names=['No Disease', 'Disease'],
                    filled=True, rounded=True,
                    special_characters=True)

    # Convert to PDF using Graphviz system command
    !dot -Tpdf {dot_path} -o {pdf_path}
    print(f"✅ Saved {pdf_path}")

print("All trees saved in /content/trees folder.")

# Zip them all
!zip -r /content/random_forest_trees.zip /content/trees

# Download the zip
files.download("/content/random_forest_trees.zip")

'''6. Select the best model
a. Print the confusion matrix of all classifiers
b. Print the classification report of all classifiers
c. Calculate Recall Precision and F1 score of all the models
d. Visualize confusion matrix using heatmaps
e. Select the best model based on the best accuracies'''

print(conf_matrix_logistic1)
print("=======================")
print(conf_matrix_decision)
print("=========================")
print(conf_matrix_random)

from sklearn.metrics import accuracy_score, classification_report, confusion_matrix
print("classification report on random forest ")
print(report_random)
print("==========================================" * 3)
print("classification report on decision tree")
print(report_decision)
print("===========================================")
print("classification report on logistic regression")
print(report_logistic1)

